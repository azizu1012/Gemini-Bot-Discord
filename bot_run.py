import logging
import discord
from discord.ext import commands
from dotenv import load_dotenv
import os
import sqlite3
import re
import json
import random
from datetime import datetime
import shutil
import sys
from datetime import timedelta
import asyncio
import sympy as sp
import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold
import requests
from serpapi import GoogleSearch  # SerpAPI (d√πng google-search-results package)
from tavily import TavilyClient  # Tavily
import exa_py  # Exa.ai (exa-py package)
from datetime import datetime, timedelta, timezone
import json
import os
from discord import app_commands
from collections import defaultdict, deque

# --- ƒê·ªäNH NGHƒ®A TOOLS CHO GEMINI (T·ªêI GI·∫¢N) ---
from google.generativeai.types import Tool, FunctionDeclaration

ALL_TOOLS = [
    Tool(function_declarations=[
        FunctionDeclaration(
            name="web_search",
            description=(
                "T√¨m ki·∫øm th√¥ng tin c·∫≠p nh·∫≠t (tin t·ª©c, gi√° c·∫£, phi√™n b·∫£n game, s·ª± ki·ªán) sau nƒÉm 2024. "
                "Ch·ªâ d√πng khi ki·∫øn th·ª©c n·ªôi b·ªô c·ªßa b·∫°n ƒë√£ l·ªói th·ªùi so v·ªõi ng√†y hi·ªán t·∫°i. "
                "Y√™u c·∫ßu T·ª∞ D·ªäCH c√¢u h·ªèi ti·∫øng Vi·ªát c·ªßa user th√†nh m·ªôt query t√¨m ki·∫øm ti·∫øng Anh T·ªêI ∆ØU."
            ),
            parameters={
                "type": "object",
                "properties": {"query": {"type": "string", "description": "C√¢u h·ªèi b·∫±ng ti·∫øng Anh"}},
                "required": ["query"]
            }
        )
    ]),
    Tool(function_declarations=[
        FunctionDeclaration(
            name="get_weather",
            description="L·∫•y th√¥ng tin th·ªùi ti·∫øt hi·ªán t·∫°i cho m·ªôt th√†nh ph·ªë c·ª• th·ªÉ.",
            parameters={
                "type": "object",
                "properties": {"city": {"type": "string", "description": "T√™n th√†nh ph·ªë, v√≠ d·ª•: 'Hanoi', 'Tokyo'."}},
                "required": ["city"]
            }
        )
    ]),
    Tool(function_declarations=[
        FunctionDeclaration(
            name="calculate",
            description="Gi·∫£i c√°c b√†i to√°n s·ªë h·ªçc ho·∫∑c bi·ªÉu th·ª©c ph·ª©c t·∫°p, bao g·ªìm c√°c h√†m l∆∞·ª£ng gi√°c, logarit, v√† ƒë·∫°i s·ªë.",
            parameters={
                "type": "object",
                "properties": {"equation": {"type": "string", "description": "Bi·ªÉu th·ª©c to√°n h·ªçc d∆∞·ªõi d·∫°ng string, v√≠ d·ª•: 'sin(pi/2) + 2*x'."}},
                "required": ["equation"]
            }
        )
    ]),
    Tool(function_declarations=[
        FunctionDeclaration(
            name="save_note",
            description="L∆∞u m·ªôt m·∫©u th√¥ng tin, ghi ch√∫ ho·∫∑c l·ªùi nh·∫Øc c·ª• th·ªÉ theo y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng ƒë·ªÉ b·∫°n c√≥ th·ªÉ truy c·∫≠p l·∫°i sau.",
            parameters={
                "type": "object",
                "properties": {"note": {"type": "string", "description": "N·ªôi dung ghi ch√∫ c·∫ßn l∆∞u."}},
                "required": ["note"]
            }
        )
    ]),
]

# === B·ªò ƒêI·ªÄU PH·ªêI TOOL ===
async def call_tool(function_call, user_id):
    name = function_call.name
    args = dict(function_call.args)  # Chuy·ªÉn sang dict ƒë·ªÉ log ƒë·∫πp
    logger.info(f"TOOL G·ªåI: {name} | Args: {args} | User: {user_id}")

    try:
        if name == "web_search":
            query = args.get("query", "")
            return await run_search_apis(query, "general")

        elif name == "get_weather":
            city = args.get("city", "Ho Chi Minh City")
            data = await get_weather(city)
            return json.dumps(data, ensure_ascii=False, indent=2)

        elif name == "calculate":
            eq = args.get("equation", "")
            return await run_calculator(eq)

        elif name == "save_note":
            note = args.get("note", "")
            return await save_note(note, user_id)

        else:
            return "Tool kh√¥ng t·ªìn t·∫°i!"

    except Exception as e:
        logger.error(f"Tool {name} l·ªói: {e}")
        return f"L·ªói tool: {str(e)}"
# --- B·∫¢N ƒê·ªí T√äN TH√ÄNH PH·ªê ---
CITY_NAME_MAP = {
    "h·ªì ch√≠ minh": ("Ho Chi Minh City", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
    "tp.hcm": ("Ho Chi Minh City", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
    "s√†i g√≤n": ("Ho Chi Minh City", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
    "ho chi minh city": ("Ho Chi Minh City", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
    "hcmc": ("Ho Chi Minh City", "Th√†nh ph·ªë H·ªì Ch√≠ Minh"),
    "h√† n·ªôi": ("Hanoi", "H√† N·ªôi"),
    "ha noi": ("Hanoi", "H√† N·ªôi"),
    "danang": ("Da Nang", "ƒê√† N·∫µng"),
    "ƒë√† n·∫µng": ("Da Nang", "ƒê√† N·∫µng"),
    "da nang": ("Da Nang", "ƒê√† N·∫µng"),
}
# --- H√ÄM CHUY·ªÇN ƒê·ªîI T√äN TH√ÄNH PH·ªê ---
def normalize_city_name(city_query):
    """Chuy·ªÉn t√™n th√†nh ph·ªë ng∆∞·ªùi d√πng nh·∫≠p v·ªÅ t√™n chu·∫©n WeatherAPI v√† t√™n ti·∫øng Vi·ªát."""
    if not city_query:
        return ("Ho Chi Minh City", "Th√†nh ph·ªë H·ªì Ch√≠ Minh")
    city_key = city_query.strip().lower()
    for k, v in CITY_NAME_MAP.items():
        if k in city_key:
            return v  # (T√™n ti·∫øng Anh, T√™n ti·∫øng Vi·ªát)
    # N·∫øu kh√¥ng kh·ªõp, tr·∫£ v·ªÅ t√™n g·ªëc (WeatherAPI s·∫Ω c·ªë g·∫Øng nh·∫≠n di·ªán)
    return (city_query, city_query.title())

# --- THI·∫æT L·∫¨P LOGGING ---
# Setup logging ‚Äì FIX DUPLICATE (THAY TO√ÄN B·ªò)
logger = logging.getLogger('bot_gemini')
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')

file_handler = logging.FileHandler('bot.log', encoding='utf-8')
file_handler.setFormatter(formatter)

stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)

logger.handlers = [file_handler, stream_handler]  # THAY H·∫æT HANDLER C≈®
logger.propagate = False  # NGƒÇN LOG L·∫∂P


# --- T·∫¢I BI·∫æN M√îI TR∆Ø·ªúNG ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GEMINI_API_KEY_PROD = os.getenv('GEMINI_API_KEY_PROD')
GEMINI_API_KEY_TEST = os.getenv('GEMINI_API_KEY_TEST')
GEMINI_API_KEY_BACKUP = os.getenv('GEMINI_API_KEY_BACKUP')
GEMINI_API_KEY_EXTRA1 = os.getenv('GEMINI_API_KEY_EXTRA1')
GEMINI_API_KEY_EXTRA2 = os.getenv('GEMINI_API_KEY_EXTRA2')
MODEL_NAME = os.getenv('MODEL_NAME')
ADMIN_ID = os.getenv('ADMIN_ID', '')
HABE_USER_ID = os.getenv('HABE_USER_ID', '')
MIRA_USER_ID = os.getenv('MIRA_USER_ID', '')
ADO_FAT_USER_ID = os.getenv('ADO_FAT_USER_ID', '')
MUC_RIM_USER_ID = os.getenv('MUC_RIM_USER_ID', '')
SUC_VIEN_USER_ID = os.getenv('SUC_VIEN_USER_ID', '')
CHUI_USER_ID = os.getenv('CHUI_USER_ID', '')

# API Keys cho Search (t·ª´ .env)
SERPAPI_API_KEY = os.getenv('SERPAPI_API_KEY')
TAVILY_API_KEY = os.getenv('TAVILY_API_KEY')
EXA_API_KEY = os.getenv('EXA_API_KEY')
GOOGLE_CSE_ID = os.getenv('GOOGLE_CSE_ID')  # ƒê√£ c√≥
GOOGLE_CSE_API_KEY = os.getenv('GOOGLE_CSE_API_KEY')  # ƒê√£ c√≥

# Global counter cho round-robin balance (chia ƒë·ªÅu 4 APIs)
SEARCH_API_COUNTER = 0
SEARCH_LOCK = asyncio.Lock()  # Lock ƒë·ªÉ an to√†n async

# File cache cho th·ªùi ti·∫øt (c·∫≠p nh·∫≠t m·ªói gi·ªù)
WEATHER_CACHE_PATH = os.path.join(os.path.dirname(__file__), 'weather_cache.json')
weather_lock = asyncio.Lock()  # Lock cho cache

# L·∫•y key & city t·ª´ .env
WEATHER_API_KEY = os.getenv('WEATHER_API_KEY')
CITY = os.getenv('CITY')

# --- ƒê∆Ø·ªúNG D·∫™N FILE (C·∫¨P NH·∫¨T) ---
DB_PATH = os.path.join(os.path.dirname(__file__), 'chat_history.db')
# (Thay ƒë·ªïi) D√πng 1 file backup c·ªë ƒë·ªãnh, kh√¥ng spam file theo ng√†y
DB_BACKUP_PATH = os.path.join(os.path.dirname(__file__),
                              'chat_history_backup.db')
NOTE_PATH = os.path.join(os.path.dirname(__file__), 'notes.txt')
# (M·ªõi) File JSON cho b·ªô nh·ªõ ng·∫Øn h·∫°n
MEMORY_PATH = os.path.join(os.path.dirname(__file__), 'short_term_memory.json')

# (M·ªõi) Lock ƒë·ªÉ tr√°nh xung ƒë·ªôt khi ƒë·ªçc/ghi file JSON
memory_lock = asyncio.Lock()
weather_lock = asyncio.Lock()

# --- THI·∫æT L·∫¨P GEMINI API KEYS CHO FAILOVER ---
GEMINI_API_KEYS = []
if GEMINI_API_KEY_PROD:
    GEMINI_API_KEYS.append(GEMINI_API_KEY_PROD)
if GEMINI_API_KEY_TEST:
    GEMINI_API_KEYS.append(GEMINI_API_KEY_TEST)
if GEMINI_API_KEY_BACKUP:
    GEMINI_API_KEYS.append(GEMINI_API_KEY_BACKUP)
if GEMINI_API_KEY_EXTRA1:
    GEMINI_API_KEYS.append(GEMINI_API_KEY_EXTRA1)
if GEMINI_API_KEY_EXTRA2:
    GEMINI_API_KEYS.append(GEMINI_API_KEY_EXTRA2)

if not GEMINI_API_KEYS:
    logger.error("Kh√¥ng t√¨m th·∫•y Gemini API keys! Bot s·∫Ω kh√¥ng th·ªÉ ho·∫°t ƒë·ªông.")
else:
    logger.info(
        f"ƒê√£ thi·∫øt l·∫≠p {len(GEMINI_API_KEYS)} Gemini API keys cho Failover.")

# --- (C·∫¨P NH·∫¨T) X·ª¨ L√ù GEMINI API V√Ä SYSTEM PROMPT ---
LAST_WORKING_KEY_INDEX = 0
current_api_index = 0
# --- CACHE SEARCH ---
SEARCH_CACHE = {}
CACHE_LOCK = asyncio.Lock()


# --- ANTI-SPAM N√ÇNG CAO ---
user_queue = defaultdict(deque)
SPAM_THRESHOLD = 3
SPAM_WINDOW = 30

# --- KH·ªûI T·∫†O BOT (CH·ªà 1 INSTANCE) ---
intents = discord.Intents.default()
intents.message_content = True
intents.dm_messages = True
bot = commands.Bot(command_prefix='!', intents=intents, help_command=None)

# --- KEEP-ALIVE WEBHOOK ---
from flask import Flask, request
import threading

# Flask app cho webhook keep-alive
keep_alive_app = Flask(__name__)

@keep_alive_app.route('/', methods=['GET', 'POST'])
def webhook():
    return "Bot alive! No sleep pls~ üò¥"

def run_keep_alive():
    port = int(os.environ.get('PORT', 8080))
    keep_alive_app.run(host='0.0.0.0', port=port, debug=False)

# --- H√ÄM GEMINI ---
# --- H√ÄM GEMINI (FIX TOOL CALLING) ---
async def run_gemini_api(messages, model_name, user_id, temperature=0.7, max_tokens=1500):
    """(FIXED) Ch·∫°y Gemini API v·ªõi Tool Calling v√† Failover Keys."""
    
    # L·∫•y danh s√°ch key t·ª´ .env (gi·ªëng code c·ªßa b·∫°n)
    keys = [GEMINI_API_KEY_PROD, GEMINI_API_KEY_TEST, GEMINI_API_KEY_BACKUP, GEMINI_API_KEY_EXTRA1, GEMINI_API_KEY_EXTRA2]
    keys = [k for k in keys if k]
    if not keys:
        return "L·ªói: Kh√¥ng c√≥ API key."

    # --- CHU·∫®N B·ªä L·ªäCH S·ª¨ CHAT (R·∫§T QUAN TR·ªåNG) ---
    # Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng message c·ªßa b·∫°n sang ƒë·ªãnh d·∫°ng Gemini
    gemini_messages = []
    system_instruction = None

    for msg in messages:
        if msg["role"] == "system":
            system_instruction = msg["content"]
            continue
            
        # X·ª≠ l√Ω tin nh·∫Øn user/assistant c≈© (ch·ªâ c√≥ text)
        if "content" in msg and isinstance(msg["content"], str):
            role = "model" if msg["role"] == "assistant" else msg["role"]
            gemini_messages.append({"role": role, "parts": [{"text": msg["content"]}]})
        
        # X·ª≠ l√Ω c√°c ph·∫ßn tool call/response ƒë√£ c√≥ trong l·ªãch s·ª≠ (n·∫øu c√≥)
        elif "parts" in msg:
            role = "model" if msg["role"] == "assistant" else msg["role"]
            gemini_messages.append({"role": role, "parts": msg["parts"]})

    # --- V√íNG L·∫∂P API KEY (FAILOVER) ---
    for i, api_key in enumerate(keys):
        logger.info(f"TH·ª¨ KEY {i+1}: {api_key[:8]}...")
        try:
            genai.configure(api_key=api_key)
            
            # (FIX) C·∫•u h√¨nh model v·ªõi tools v√† system_instruction
            model = genai.GenerativeModel(
                model_name,
                tools=ALL_TOOLS,
                system_instruction=system_instruction,
                safety_settings=[{"category": c, "threshold": HarmBlockThreshold.BLOCK_NONE} for c in [
                    HarmCategory.HARM_CATEGORY_HARASSMENT,
                    HarmCategory.HARM_CATEGORY_HATE_SPEECH,
                    HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
                    HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
                ]],
                generation_config={"temperature": temperature, "max_output_tokens": max_tokens}
            )

            # --- (FIX) V√íNG L·∫∂P TOOL CALLING (T·ªëi ƒëa 3 l·∫ßn) ---
            for _ in range(3): # Gi·ªõi h·∫°n 3 l·∫ßn g·ªçi tool
                
                # (FIX) D√πng model.generate_content, kh√¥ng d√πng start_chat
                response = await asyncio.to_thread(
                    model.generate_content,
                    gemini_messages
                )
                
                if not response.candidates or not response.candidates[0].content.parts:
                    logger.warning(f"Key {i+1} tr·∫£ v·ªÅ response r·ªóng.")
                    break # Th·ª≠ key ti·∫øp theo

                part = response.candidates[0].content.parts[0]

                # === (FIX) KI·ªÇM TRA TOOL CALL TR∆Ø·ªöC ===
                if part.function_call:
                    fc = part.function_call
                    
                    # 1. Th√™m y√™u c·∫ßu c·ªßa AI v√†o l·ªãch s·ª≠
                    gemini_messages.append({
                        "role": "model",
                        "parts": [part] 
                    })
                    
                    # 2. Th·ª±c thi tool (h√†m call_tool c·ªßa b·∫°n)
                    tool_result_content = await call_tool(fc, user_id)
                    
                    # 3. Th√™m k·∫øt qu·∫£ tool v√†o l·ªãch s·ª≠
                    tool_response_part = {
                        "function_response": {
                            "name": fc.name,
                            "response": {"content": tool_result_content},
                        }
                    }
                    gemini_messages.append({
                        "role": "function", # Vai tr√≤ ƒë·∫∑c bi·ªát
                        "parts": [tool_response_part]
                    })
                    
                    # 4. Ti·∫øp t·ª•c v√≤ng l·∫∑p (g·ªçi l·∫°i Gemini v·ªõi l·ªãch s·ª≠ m·ªõi)
                    continue 

                # === (FIX) KI·ªÇM TRA TEXT SAU ===
                elif part.text:
                    # AI tr·∫£ l·ªùi b·∫±ng text (TH√ÄNH C√îNG)
                    logger.info(f"KEY {i+1} TH√ÄNH C√îNG!")
                    return part.text.strip()
                
                else:
                    # Tr∆∞·ªùng h·ª£p l·∫°, kh√¥ng text c≈©ng kh√¥ng tool
                    logger.warning(f"Key {i+1} tr·∫£ v·ªÅ part kh√¥ng c√≥ text/tool.")
                    break # Th·ª≠ key ti·∫øp theo

            # N·∫øu l·∫∑p qu√° 3 l·∫ßn m√† v·∫´n g·ªçi tool, tr·∫£ v·ªÅ l·ªói
            logger.warning(f"Key {i+1} l·∫∑p tool qu√° 3 l·∫ßn.")
            # Fallback: Th·ª≠ l·∫•y text cu·ªëi c√πng n·∫øu c√≥ (tr√°nh crash)
            try:
                if response.text:
                    logger.info(f"KEY {i+1} TH√ÄNH C√îNG! (sau loop)")
                    return response.text.strip()
            except Exception:
                pass # B·ªè qua n·∫øu v·∫´n l·ªói
                
            # N·∫øu kh√¥ng th√†nh c√¥ng, ti·∫øp t·ª•c th·ª≠ key sau
            raise Exception("Tool loop ended or part was empty")

        except Exception as e:
            # (FIX) B·∫Øt l·ªói r√µ r√†ng h∆°n
            if "Could not convert" in str(e):
                logger.error(f"KEY {i+1} L·ªñI LOGIC: {e}") # ƒê√¢y l√† l·ªói code
            else:
                logger.error(f"KEY {i+1} L·ªñI K·∫æT N·ªêI/API: {e}") # ƒê√¢y l√† l·ªói key/m·∫°ng
            continue # Th·ª≠ key ti·∫øp theo

    return "L·ªói: T·∫§T C·∫¢ KEY GEMINI FAIL ‚Äì CHECK .ENV HO·∫∂C LOG!"

# --- THEO D√ïI L·ªäCH S·ª¨ NH·∫ÆN V√Ä X√ÅC NH·∫¨N X√ìA D·ªÆ LI·ªÜU ---
mention_history = {}
confirmation_pending = {}  # Dict ƒë·ªÉ track x√≥a data user
admin_confirmation_pending = {}  # (M·ªõi) Dict ƒë·ªÉ track x√≥a data admin

# --- QU·∫¢N L√ù DATABASE (SQLITE) ---


# C·∫£i thi·ªán: Ch·ªâ l·ªçc n·∫øu c√≥ t·ª´ kh√≥a + kh√¥ng l√†m h·ªèng c√¢u
def sanitize_query(query):
    dangerous = [
        r'\bignore\s+(previous|all|earlier|instructions)\b',
        r'\bforget\s+(everything|previous|all)\b',
        r'\bjailbreak\b', r'\bDAN\b', r'\b(system\s*prompt)\b',
        r'\bros\.system\b', r'\brole\s*play\s+as\s+(admin|system)\b'
    ]
    for pattern in dangerous:
        if re.search(pattern, query, re.IGNORECASE):
            query = re.sub(pattern, '[REDACTED]', query, flags=re.IGNORECASE)
    return query

def is_negative_comment(text):
    negative_patterns = [
        r'ch∆°i\s+ngu', r'ngu\s+vcl', r'(k√©m|d·ªü|t·ªá|x·∫•u)\s+game',
        r'(feeder|inter|troll)', r'ch∆°i (k√©m|d·ªü|t·ªá|x·∫•u)',
        r'kh√¥ng (gi·ªèi|hay|pro)', r'noob', r'qu√° t·ªá', r'thua t·∫°i', r'ph·∫ø',
        r'ƒÉn h·∫°i', r'qu√° g√†', 'kh√¥ng bi·∫øt ch∆°i', r'ƒë√°nh d·ªü', r'ƒë√°nh ngu',
        r'ngu v√£i', r'ngu th·∫≠t', r'ngu th·∫ø', r'ngu v·∫≠y'
    ]
    text_lower = text.lower()
    return any(re.search(pattern, text_lower) for pattern in negative_patterns)


def backup_db():
    if os.path.exists(DB_PATH):
        try:
            conn = sqlite3.connect(DB_PATH, timeout=10)
            try:
                conn.execute("SELECT 1 FROM sqlite_master WHERE type='table'")
                # (Thay ƒë·ªïi) Ghi ƒë√® v√†o 1 file backup duy nh·∫•t
                shutil.copy2(DB_PATH, DB_BACKUP_PATH)
                logger.info(f"DB backed up to {DB_BACKUP_PATH}")
            finally:
                conn.close()
        except sqlite3.DatabaseError as e:
            logger.error(f"Cannot backup DB: {str(e)}. Creating new DB.")
            init_db()


def cleanup_db():
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()
        old_date = (datetime.now() - timedelta(days=30)).isoformat()
        c.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='messages'"
        )
        if c.fetchone():
            c.execute("DELETE FROM messages WHERE timestamp < ?", (old_date, ))
        conn.commit()
        logger.info("DB cleaned: Old messages deleted.")
    except sqlite3.DatabaseError as e:
        logger.error(f"Cannot clean DB: {str(e)}. Creating new DB.")
        init_db()
    finally:
        if conn:
            conn.close()


def init_db():
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS messages
                     (user_id TEXT, role TEXT, content TEXT, timestamp TEXT)'''
                  )
        conn.commit()
        logger.info("DB initialized")
    except sqlite3.DatabaseError as e:
        logger.error(f"Cannot initialize DB: {str(e)}. Creating new DB.")
        if conn:
            conn.close()
        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS messages
                     (user_id TEXT, role TEXT, content TEXT, timestamp TEXT)'''
                  )
        conn.commit()
        logger.info("New DB created")
    finally:
        if conn:
            conn.close()


# --- (M·ªöI) QU·∫¢N L√ù B·ªò NH·ªö NG·∫ÆN H·∫†N (JSON) ---


def init_json_memory():
    """Kh·ªüi t·∫°o file JSON n·∫øu ch∆∞a t·ªìn t·∫°i."""
    if not os.path.exists(MEMORY_PATH):
        try:
            with open(MEMORY_PATH, 'w', encoding='utf-8') as f:
                json.dump({}, f)
            logger.info(f"Created new short term memory file: {MEMORY_PATH}")
        except Exception as e:
            logger.error(f"Failed to create memory file: {e}")


async def load_json_memory():
    """T·∫£i b·ªô nh·ªõ t·ª´ file JSON (an to√†n v·ªõi Lock)."""
    async with memory_lock:
        if not os.path.exists(MEMORY_PATH):
            init_json_memory()
            return {}
        try:
            with open(MEMORY_PATH, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError:
            logger.error("Failed to decode memory JSON, resetting file.")
            init_json_memory()
            return {}
        except Exception as e:
            logger.error(f"Failed to load memory file: {e}")
            return {}


async def save_json_memory(data):
    """L∆∞u b·ªô nh·ªõ v√†o file JSON (an to√†n v·ªõi Lock)."""
    async with memory_lock:
        try:
            with open(MEMORY_PATH, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Failed to save memory file: {e}")

# --- (C·∫¨P NH·∫¨T) C√ÅC H√ÄM LOG V√Ä L·∫§Y L·ªäCH S·ª¨ ---


async def log_message(user_id, role, content):
    # 1. Log v√†o DB (l∆∞u tr·ªØ l√¢u d√†i)
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()
        timestamp = datetime.now().isoformat()
        c.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='messages'"
        )
        if not c.fetchone():
            init_db()
            conn.close()
            conn = sqlite3.connect(DB_PATH, timeout=10)
            c = conn.cursor()

        c.execute(
            "INSERT INTO messages (user_id, role, content, timestamp) VALUES (?, ?, ?, ?)",
            (user_id, role, content, timestamp))
        conn.commit()
    except sqlite3.DatabaseError as e:
        logger.error(f"Database error while logging: {str(e)}")
        init_db()
    finally:
        if conn:
            conn.close()

    # 2. (M·ªõi) Log v√†o JSON (b·ªô nh·ªõ ng·∫Øn h·∫°n cho AI)
    try:
        memory = await load_json_memory()
        if user_id not in memory:
            memory[user_id] = []

        memory[user_id].append({"role": role, "content": content})
        # Gi·ªØ 10 tin nh·∫Øn cu·ªëi c√πng (5 c·∫∑p user/assistant)
        memory[user_id] = memory[user_id][-10:]

        await save_json_memory(memory)
    except Exception as e:
        logger.error(f"Failed to update JSON memory for {user_id}: {e}")

    # 3. Log ra console
    if role == "user":
        logger.info(f"User {user_id} sent a message")
    elif role == "assistant" and "DM reply" in content:
        logger.info(f"Bot sent DM to user mentioned in message")


def get_user_history(user_id):
    """
    (Thay ƒë·ªïi) L·∫•y l·ªãch s·ª≠ t·ª´ file JSON thay v√¨ DB.
    V√¨ h√†m n√†y ƒë∆∞·ª£c g·ªçi trong on_message (async), ch√∫ng ta c·∫ßn c√°ch g·ªçi ƒë·ªìng b·ªô.
    Tuy nhi√™n, get_user_history ƒë∆∞·ª£c g·ªçi trong 1 h√†m ASYNC (on_message),
    n√™n ta s·∫Ω ƒë·ªïi n√≥ th√†nh h√†m async.
    """
    logger.error("H√†m get_user_history (ƒë·ªìng b·ªô) ƒë√£ b·ªã g·ªçi. L·ªói logic.")
    return []  # Tr·∫£ v·ªÅ r·ªóng ƒë·ªÉ tr√°nh l·ªói, h√†m n√†y kh√¥ng n√™n ƒë∆∞·ª£c d√πng n·ªØa


async def get_user_history_async(user_id):
    """(M·ªõi) L·∫•y l·ªãch s·ª≠ 10 tin nh·∫Øn cu·ªëi t·ª´ JSON."""
    memory = await load_json_memory()
    return memory.get(user_id, [])


def is_rate_limited(user_id):
    now = datetime.now()
    if user_id not in mention_history:
        mention_history[user_id] = []
    mention_history[user_id] = [
        ts for ts in mention_history[user_id]
        if now - ts < timedelta(minutes=1)
    ]
    if len(mention_history[user_id]) >= 25:
        return True
    mention_history[user_id].append(now)
    return False

# --- (C·∫¨P NH·∫¨T) L·∫§Y TH·ªúI TI·∫æT T·ª™ WEATHERAPI ---
async def get_weather(city_query=None):
    """L·∫•y th·ªùi ti·∫øt current + 6 ng√†y forecast, cache 1 gi·ªù. Lu√¥n tr·∫£ dict."""
    async with weather_lock:
        # N·∫øu kh√¥ng truy·ªÅn city_query th√¨ l·∫•y t·ª´ .env
        city_env = CITY or "Ho Chi Minh City"
        city_query = city_query or city_env
        city_en, city_vi = normalize_city_name(city_query)

        # T·∫°o cache ri√™ng cho t·ª´ng th√†nh ph·ªë
        cache_path = WEATHER_CACHE_PATH.replace(".json", f"_{city_en.replace(' ', '_').lower()}.json")

        # Ki·ªÉm tra cache
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r') as f:
                    cache = json.load(f)
                cache_time = datetime.fromisoformat(cache['timestamp'])
                if datetime.now() - cache_time < timedelta(hours=1):
                    return {**cache['data'], "city_vi": city_vi}  # Tr·∫£ cache n·∫øu <1h
            except:
                pass

        # G·ªçi API n·∫øu cache c≈© ho·∫∑c kh√¥ng c√≥
        if not WEATHER_API_KEY:
            default_data = {
                'current': f'M∆∞a r√†o s√°ng, m√¢y chi·ªÅu ·ªü {city_vi} (23-28¬∞C).',
                'forecast': [f'Ng√†y mai: N·∫Øng, 26¬∞C', f'Ng√†y kia: M∆∞a, 25¬∞C'] * 3,
                'timestamp': datetime.now().isoformat(),
                'city_vi': city_vi
            }
            with open(cache_path, 'w') as f:
                json.dump({'data': default_data, 'timestamp': datetime.now().isoformat()}, f)
            return default_data

        try:
            url = f"http://api.weatherapi.com/v1/forecast.json?key={WEATHER_API_KEY}&q={city_en}&days=7&aqi=no&alerts=no"
            response = requests.get(url, timeout=10)
            if response.status_code != 200:
                raise ValueError(f"API status: {response.status_code}")

            data = response.json()
            if 'error' in data:
                raise ValueError(f"API error: {data['error']['message']}")

            current = data['current']['condition']['text'] + f" ({data['current']['temp_c']}¬∞C)"
            forecast = []
            for day in data['forecast']['forecastday'][1:7]:
                forecast.append(f"Ng√†y {day['date']}: {day['day']['condition']['text']} ({day['day']['avgtemp_c']}¬∞C)")

            weather_data = {
                'current': current,
                'forecast': forecast,
                'timestamp': datetime.now().isoformat(),
                'city_vi': city_vi
            }

            cache_entry = {'data': weather_data, 'timestamp': datetime.now().isoformat()}
            with open(cache_path, 'w') as f:
                json.dump(cache_entry, f, indent=2)

            return weather_data
        except Exception as e:
            logger.error(f"Weather API l·ªói: {e}")
            fallback_data = {
                'current': f'L·ªói API, d√πng m·∫∑c ƒë·ªãnh: M∆∞a r√†o ·ªü {city_vi}, 23-28¬∞C.',
                'forecast': [f'Ng√†y mai: N·∫Øng, 26¬∞C', f'Ng√†y kia: M∆∞a, 25¬∞C'] * 3,
                'timestamp': datetime.now().isoformat(),
                'city_vi': city_vi
            }
            with open(cache_path, 'w') as f:
                json.dump({'data': fallback_data, 'timestamp': datetime.now().isoformat()}, f)
            return fallback_data
        
# --- SEARCH CACHE ---
async def cached_search(key, func, *args):
    async with CACHE_LOCK:
        if key in SEARCH_CACHE and datetime.now() - SEARCH_CACHE[key]['time'] < timedelta(hours=6):
            return SEARCH_CACHE[key]['result']
        result = await func(*args)
        SEARCH_CACHE[key] = {'result': result, 'time': datetime.now()}
        return result

# --- L·∫§Y GI·ªú HI·ªÜN T·∫†I VN (UTC+7) ---
def get_current_time():
    """L·∫•y gi·ªù hi·ªán t·∫°i VN (UTC+7)."""
    now = datetime.now() + timedelta(hours=7)  # UTC to VN
    return now.strftime('%H:%M %d/%m/%Y, th·ª© %A')

# --- C√ÅC TOOL C∆† B·∫¢N (KH√îNG ƒê·ªîI) ---


# Tool: Calculator
def run_calculator(query):
    try:
        query = query.lower().replace("t√≠nh ", "").replace("calculate ",
                                                           "").strip()
        if not re.match(r'^[\d\s+\-*/^()sin|cos|tan|sqrt|log|exp]*$', query):
            return None
        expr = sp.sympify(query, evaluate=False)
        result = sp.N(expr)
        return f"K·∫øt qu·∫£: {result}"
    except sp.SympifyError:
        return None
    except Exception as e:
        return f"L·ªói t√≠nh to√°n: {str(e)}"


# Tool: Save Note
def save_note(query):
    try:
        note = query.lower().replace("ghi note: ",
                                     "").replace("save note: ", "").strip()
        with open(NOTE_PATH, 'a', encoding='utf-8') as f:
            f.write(f"[{datetime.now().isoformat()}] {note}\n")
        return f"ƒê√£ ghi note: {note}"
    except PermissionError:
        return "L·ªói: Kh√¥ng c√≥ quy·ªÅn ghi file notes.txt!"
    except Exception as e:
        return f"L·ªói ghi note: {str(e)}"


# Tool: Read Note
def read_note():
    try:
        if not os.path.exists(NOTE_PATH):
            return "Ch∆∞a c√≥ note n√†o bro! Ghi note ƒëi nha! üòé"
        with open(NOTE_PATH, 'r', encoding='utf-8') as f:
            notes = f.readlines()
        if not notes:
            return "Ch∆∞a c√≥ note n√†o bro! Ghi note ƒëi nha! üòé"
        return "Danh s√°ch note:\n" + "".join(
            notes[-5:])  # L·∫•y t·ªëi ƒëa 5 note m·ªõi nh·∫•t
    except PermissionError:
        return "L·ªói: Kh√¥ng c√≥ quy·ªÅn ƒë·ªçc file notes.txt!"
    except Exception as e:
        return f"L·ªói ƒë·ªçc note: {str(e)}"


# --- (C·∫¨P NH·∫¨T) C√ÅC H√ÄM X√ìA D·ªÆ LI·ªÜU ---


async def clear_user_data(user_id):
    """(Thay ƒë·ªïi) X√≥a c·∫£ trong DB v√† trong JSON memory."""
    db_cleared = False
    json_cleared = False

    # 1. X√≥a trong DB (cho log)
    conn = None
    for attempt in range(3):  # Retry t·ªëi ƒëa 3 l·∫ßn
        try:
            conn = sqlite3.connect(DB_PATH, timeout=10)
            c = conn.cursor()
            c.execute("DELETE FROM messages WHERE user_id = ?", (user_id, ))
            conn.commit()
            logger.info(f"User {user_id} history cleared from DB")
            db_cleared = True
            break
        except sqlite3.OperationalError as e:
            if "database is locked" in str(e):
                logger.warning(
                    f"Database locked (clear_user_data), retry {attempt + 1}/3"
                )
                await asyncio.sleep(1)
                continue
            logger.error(f"Cannot clear DB history for {user_id}: {str(e)}")
        except sqlite3.DatabaseError as e:
            logger.error(f"Cannot clear DB history for {user_id}: {str(e)}")
        finally:
            if conn:
                conn.close()

    # 2. X√≥a trong JSON (cho AI memory)
    try:
        memory = await load_json_memory()
        if user_id in memory:
            del memory[user_id]
            await save_json_memory(memory)
            logger.info(f"User {user_id} history cleared from JSON memory")
            json_cleared = True
        else:
            json_cleared = True  # Coi nh∆∞ th√†nh c√¥ng n·∫øu kh√¥ng c√≥
    except Exception as e:
        logger.error(f"Failed to clear JSON memory for {user_id}: {e}")

    return db_cleared and json_cleared


async def clear_all_data():
    """(M·ªõi) X√≥a to√†n b·ªô l·ªãch s·ª≠ DB v√† reset JSON. Ch·ªâ admin."""
    db_cleared = False
    json_cleared = False

    # 1. X√≥a DB
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()
        c.execute("DELETE FROM messages")
        conn.commit()
        logger.info("ADMIN: Cleared all data from messages table.")
        db_cleared = True
    except sqlite3.DatabaseError as e:
        logger.error(f"ADMIN: Failed to clear DB: {e}")
    finally:
        if conn:
            conn.close()

    # 2. Reset JSON
    try:
        await save_json_memory({})  # Ghi ƒë√® file r·ªóng
        logger.info("ADMIN: Reset JSON memory file.")
        json_cleared = True
    except Exception as e:
        logger.error(f"ADMIN: Failed to reset JSON memory: {e}")

    return db_cleared and json_cleared

# --- SLASH COMMANDS DISCORD ---
#Kh·ªüi t·∫°o bot
@bot.tree.command(name="reset-chat", description="X√≥a l·ªãch s·ª≠ chat c·ªßa b·∫°n")
async def reset_chat_slash(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    confirmation_pending[user_id] = {'timestamp': datetime.now(), 'awaiting': True}
    await interaction.response.send_message("Ch·∫Øc ch·∫Øn x√≥a l·ªãch s·ª≠ chat? Reply **yes** ho·∫∑c **y** trong 60 gi√¢y! üò≥", ephemeral=True)

@bot.tree.command(name="reset-all", description="X√≥a to√†n b·ªô DB (CH·ªà ADMIN)")
async def reset_all_slash(interaction: discord.Interaction):
    if str(interaction.user.id) != ADMIN_ID:
        await interaction.response.send_message("Ch·ªâ admin m·ªõi ƒë∆∞·ª£c d√πng! üòù", ephemeral=True)
        return
    admin_confirmation_pending[str(interaction.user.id)] = {'timestamp': datetime.now(), 'awaiting': True}
    await interaction.response.send_message("‚ö†Ô∏è **ADMIN CONFIRM**: Reply **YES RESET** trong 60 gi√¢y ƒë·ªÉ x√≥a to√†n b·ªô DB + Memory!", ephemeral=True)

@bot.tree.command(name="dm", description="G·ª≠i DM (CH·ªà ADMIN)")
@app_commands.describe(user_id="ID user nh·∫≠n DM", message="N·ªôi dung DM")
async def dm_slash(interaction: discord.Interaction, user_id: str, message: str):
    if str(interaction.user.id) != ADMIN_ID:
        await interaction.response.send_message("Ch·ªâ admin! üòù", ephemeral=True)
        return
    try:
        user = await bot.fetch_user(int(user_id))
        await user.send(f"üíå T·ª´ admin: {message}")
        await interaction.response.send_message(f"ƒê√£ g·ª≠i DM cho {user}! ‚ú®", ephemeral=True)
    except:
        await interaction.response.send_message("L·ªói g·ª≠i DM! üò¢", ephemeral=True)

# --- H√ÄM BALANCE SEARCH APIs (THAY TH·∫æ OLLAMA) ---
async def run_search_apis(query, focus="general"):
    logger.info(f"CALLING SEARCH APIs for '{query}' (focus: {focus})")
    """Balance 4 APIs: CSE (0), SerpAPI (1), Tavily (2), Exa (3). Fallback n·∫øu fail."""
    global SEARCH_API_COUNTER
    apis = ["CSE", "SerpAPI", "Tavily", "Exa"]
    
    async with SEARCH_LOCK:
        idx = SEARCH_API_COUNTER % 4
        SEARCH_API_COUNTER += 1  # Round-robin
    
    tried = set()
    start_idx = idx
    
    for i in range(4):  # Th·ª≠ t·ªëi ƒëa 4 l·∫ßn (fallback chain)
        api_idx = (start_idx + i) % 4
        if api_idx in tried:
            continue
        tried.add(api_idx)
        api_name = apis[api_idx]
        
        try:
            if api_name == "CSE":
                result = await _search_cse(query) # B·ªè focus
            elif api_name == "SerpAPI":
                if not SERPAPI_API_KEY: continue
                result = await _search_serpapi(query) # B·ªè focus
            elif api_name == "Tavily":
                if not TAVILY_API_KEY: continue
                result = await _search_tavily(query) # B·ªè focus
            elif api_name == "Exa":
                if not EXA_API_KEY: continue
                result = await _search_exa(query) # B·ªè focus
            
            if result and result.strip():  # N·∫øu c√≥ k·∫øt qu·∫£ h·ª£p l·ªá
                logger.info(f"Search th√†nh c√¥ng v·ªõi {api_name} cho query: {query[:50]}...")
                return result
        
        except Exception as e:
            logger.error(f"{api_name} fail cho query '{query}': {e}")
            continue
    
    logger.warning(f"T·∫•t c·∫£ 4 APIs fail cho query: {query}")
    return ""

# -------------------------------------------------------------------------
# C√ÅC H√ÄM HELPER: L·∫§Y QUERY T·ª™ GEMINI V√Ä CH·∫†Y TH·∫≤NG
# -------------------------------------------------------------------------

async def _search_cse(query):
    """CSE: D√πng query c·ªßa Gemini, ∆∞u ti√™n k·∫øt qu·∫£ VN (gl=vn), ng√¥n ng·ªØ (hl) t√πy thu·ªôc query."""
    params = {
        'key': GOOGLE_CSE_API_KEY, 
        'cx': GOOGLE_CSE_ID, 
        'q': query, # D√πng query T·ª™ GEMINI
        'num': 3, 
        'gl': 'vn', # ∆Øu ti√™n ƒë·ªãa ƒëi·ªÉm VN (c√≥ th·ªÉ ƒë·ªïi th√†nh 'us' n·∫øu query r√µ r√†ng l√† US-focused)
        'hl': 'en' if re.search(r'[a-zA-Z]{4,}', query) else 'vi' # D√πng ng√¥n ng·ªØ t∆∞∆°ng ·ª©ng
    }
    
    response = await asyncio.to_thread(requests.get, "https://www.googleapis.com/customsearch/v1", params=params, timeout=10)
    data = response.json()
    
    if 'items' not in data:
        return ""
    
    # ... (Logic format k·∫øt qu·∫£ gi·ªØ nguy√™n) ...
    relevant = []
    for item in data['items'][:3]:
        title = item.get('title', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')
        snippet = item.get('snippet', '')[:330] + "..." if len(item.get('snippet', '')) > 130 else item.get('snippet', '')
        link = item.get('link', '')
        if any(ad in link.lower() for ad in ['shopee', 'lazada', 'amazon', 'tiki']): continue
        relevant.append(f"**{title}**: {snippet} (Ngu·ªìn: {link})")
    
    return "**Search CSE (Dynamic):**\n" + "\n".join(relevant) + "\n\n[D√ôNG ƒê·ªÇ TR·∫¢ L·ªúI E-GIRL, KH√îNG LEAK NGU·ªíN]" if relevant else ""

async def _search_serpapi(query):
    """SerpAPI: D√πng query c·ªßa Gemini, t·ªëi gi·∫£n h√≥a params."""
    if not SERPAPI_API_KEY: return ""
    
    params = {
        "q": query, # D√πng query T·ª™ GEMINI
        "api_key": SERPAPI_API_KEY,
        "engine": "google",
        "num": 3,
        "gl": "vn",
        "hl": "en" if re.search(r'[a-zA-Z]{4,}', query) else "vi" 
    }
    
    search = GoogleSearch(params)
    results = await asyncio.to_thread(search.get_dict)
    
    if 'organic_results' not in results:
        return ""
    
    # ... (Logic format k·∫øt qu·∫£ gi·ªØ nguy√™n) ...
    relevant = []
    for item in results['organic_results'][:3]:
        title = item.get('title', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')
        snippet = item.get('snippet', '')[:330] + "..." if len(item.get('snippet', '')) > 130 else item.get('snippet', '')
        link = item.get('link', '')
        if any(ad in link.lower() for ad in ['shopee', 'lazada', 'amazon', 'tiki']): continue
        relevant.append(f"**{title}**: {snippet} (Ngu·ªìn: {link})")
    
    return "**Search SerpAPI (Dynamic):**\n" + "\n".join(relevant) + "\n\n[D√ôNG ƒê·ªÇ TR·∫¢ L·ªúI E-GIRL, KH√îNG LEAK NGU·ªíN]" if relevant else ""

async def _search_tavily(query):
    """Tavily: D√πng query c·ªßa Gemini, client.search() c∆° b·∫£n."""
    if not TAVILY_API_KEY: return ""
    
    tavily = TavilyClient(api_key=TAVILY_API_KEY)
    params = {
        "query": query, # D√πng query T·ª™ GEMINI
        "search_depth": "basic", 
        "max_results": 3, 
        "include_answer": False
    }
    
    results = await asyncio.to_thread(tavily.search, **params)
    
    if 'results' not in results:
        return ""
    
    # ... (Logic format k·∫øt qu·∫£ gi·ªØ nguy√™n) ...
    relevant = []
    for item in results['results'][:3]:
        title = item.get('title', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')
        snippet = item.get('content', '')[:330] + "..." if len(item.get('content', '')) > 130 else item.get('content', '')
        link = item.get('url', '')
        if any(ad in link.lower() for ad in ['shopee', 'lazada', 'amazon', 'tiki']): continue
        relevant.append(f"**{title}**: {snippet} (Ngu·ªìn: {link})")
    
    return "**Search Tavily (Dynamic):**\n" + "\n".join(relevant) + "\n\n[D√ôNG ƒê·ªÇ TR·∫¢ L·ªúI E-GIRL, KH√îNG LEAK NGU·ªíN]" if relevant else ""

async def _search_exa(query):
    """Exa.ai: D√πng query c·ªßa Gemini, t√¨m ki·∫øm neural search c∆° b·∫£n."""
    if not EXA_API_KEY: return ""
    
    exa = exa_py.Exa(api_key=EXA_API_KEY)
    params = {
        "query": query, # D√πng query T·ª™ GEMINI
        "num_results": 3, 
        "use_autoprompt": True, 
        "type": "neural" # Neural search l√† ch·∫ø ƒë·ªô m·∫°nh nh·∫•t c·ªßa Exa
    }
    
    results = await asyncio.to_thread(exa.search, **params)
    
    if not results.results:
        return ""
    
    # ... (Logic format k·∫øt qu·∫£ gi·ªØ nguy√™n) ...
    relevant = []
    for item in results.results[:3]:
        title = item.title or 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ'
        snippet = item.text[:330] + "..." if len(item.text or '') > 130 else item.text or ''
        link = item.url
        if any(ad in link.lower() for ad in ['shopee', 'lazada', 'amazon', 'tiki']): continue
        relevant.append(f"**{title}**: {snippet} (Ngu·ªìn: {link})")
    
    return "**Search Exa.ai (Dynamic):**\n" + "\n".join(relevant) + "\n\n[D√ôNG ƒê·ªÇ TR·∫¢ L·ªúI E-GIRL, KH√îNG LEAK NGU·ªíN]" if relevant else ""
# --- L·ªÜNH ADMIN (KH√îNG ƒê·ªîI) ---


@bot.command()
async def who(ctx, user_id: str):
    if str(ctx.author.id) != ADMIN_ID:
        await ctx.send("Ch·ªâ admin d√πng l·ªánh n√†y ƒë∆∞·ª£c nha! üòù")
        return
    user = ctx.guild.get_member(int(user_id))
    if user:
        await ctx.send(f"User: {user.display_name} (ID: {user.id})")
    else:
        await ctx.send(f"Kh√¥ng t√¨m th·∫•y user {user_id} trong server n√®! üò¢")


@bot.command(name='dm')
async def send_dm(ctx, user_id: int, *, message: str):
    if str(ctx.author.id) != ADMIN_ID:
        await ctx.send("Hihi, ch·ªâ admin m·ªõi ƒë∆∞·ª£c d√πng l·ªánh n√†y nha~ üòù",
                       reference=ctx.message)
        logger.info(
            f"User {ctx.author.id} attempted to use !dm but is not ADMIN_ID")
        return
    user = bot.get_user(user_id)
    if user is None:
        await ctx.send(
            f"√îi, kh√¥ng t√¨m th·∫•y user v·ªõi ID {user_id} ƒë√¢u n√®! üò¢ Check l·∫°i ƒëi bro~",
            reference=ctx.message)
        logger.warning(
            f"User {user_id} not found for DM attempt by {ctx.author.id}")
        return
    try:
        await user.send(f"Psst! Tin nh·∫Øn t·ª´ admin n√®: {message} üíå")
        await ctx.send(
            f"ƒê√£ g·ª≠i DM cho {user.display_name} ({user.id}) th√†nh c√¥ng r√πi! ‚ú® N·ªôi dung: {message}"
        )
        await log_message(str(ctx.author.id), "assistant",
                          f"Sent DM to {user.id}: {message}")
        logger.info(f"DM sent to {user.id} by {ctx.author.id}: {message}")
    except discord.Forbidden:
        await ctx.send(
            f"Kh√¥ng g·ª≠i ƒë∆∞·ª£c DM cho {user.display_name} ƒë√¢u! üò¢ C√≥ th·ªÉ h·ªç ch·∫∑n tui ho·∫∑c kh√¥ng c√πng server n√®~"
        )
        logger.warning(f"Forbidden: Cannot send DM to {user.id}")
    except Exception as e:
        await ctx.send(f"Glitch r·ªìi bro! üò´ L·ªói: {str(e)}")
        logger.error(
            f"Error sending DM to {user.id} by {ctx.author.id}: {str(e)}")


# --- S·ª∞ KI·ªÜN BOT ---

@bot.event
async def on_ready():
    try:
        synced = await bot.tree.sync()
        logger.info(f"ƒê√£ sync {len(synced)} slash commands!")
    except Exception as e:
        logger.error(f"L·ªói sync slash: {e}")
    # ... (gi·ªØ nguy√™n init_db, cleanup_db, backup_db)
    logger.info(f'{bot.user} online!')


# --- H·ªñ TR·ª¢ DM (KH√îNG ƒê·ªîI) ---


def extract_dm_target_and_content(query):
    query_lower = query.lower()
    special_map = {
        "b√© h√†": HABE_USER_ID,
        "h√†": HABE_USER_ID,
        "mira": MIRA_USER_ID,
        "ado fat": ADO_FAT_USER_ID,
        "m·ª±c rim": MUC_RIM_USER_ID,
        "s√∫c vi√™n": SUC_VIEN_USER_ID,
        "ch√∫i": CHUI_USER_ID,
        "admin": ADMIN_ID
    }
    # T√¨m mention <@id>
    mention = re.search(r'<@!?(\d+)>', query)
    if mention:
        target_id = mention.group(1)
        content = re.sub(r'<@!?\d+>', '', query)
    else:
        # T√¨m t√™n
        for name, uid in special_map.items():
            if name in query_lower:
                target_id = uid
                content = query_lower.replace(name, '').strip()
                break
        else:
            return None, None

    # Lo·∫°i b·ªè t·ª´ kh√≥a DM
    for kw in ['nh·∫Øn', 'dm', 'g·ª≠i', 'tr·ª±c ti·∫øp', 'v·ªõi', 'cho', 'k√™u', 't·ªõi']:
        content = re.sub(rf'\b{kw}\b', '', content, flags=re.IGNORECASE)
    content = ' '.join(content.split())
    return target_id, content if content else None


async def expand_dm_content(content):
    prompt = f"M·ªü r·ªông tin nh·∫Øn sau th√†nh c√¢u d√†i h∆°n, gi·ªØ nguy√™n √Ω nghƒ©a, th√™m ch√∫t d·ªÖ th∆∞∆°ng:\n{content}"
    try:
        # (Thay ƒë·ªïi) Ch·ªâ c·∫ßn 1 tin nh·∫Øn system, run_gemini_api s·∫Ω x·ª≠ l√Ω
        messages = [{"role": "system", "content": prompt}]
        expanded = await run_gemini_api(messages,
                                        MODEL_NAME,
                                        temperature=0.3,
                                        max_tokens=200)
        return expanded if not expanded.startswith("L·ªói:") else content
    except:
        return content


async def safe_fetch_user(bot, user_id):
    try:
        return await bot.fetch_user(int(user_id))
    except:
        return None


# --- (C·∫¨P NH·∫¨T) X·ª¨ L√ù TOOL COMMANDS (TH√äM !RESETALL) ---


def handle_tool_commands(query, user_id, message, is_admin):
    q = query.lower()
    if re.match(r'^(t√≠nh|calculate)\s+|^[\d\s+\-*/^().sincoqrtlgepx]+$', q):
        return run_calculator(query)
    if q.startswith("ghi note:") or q.startswith("save note:"):
        return save_note(query)
    if q in ["ƒë·ªçc note", "read note", "xem note"]:
        return read_note()
    if re.search(r'x√≥a (data|l·ªãch s·ª≠|chat)|clear history|reset chat', q):
        confirmation_pending[user_id] = {
            'timestamp': datetime.now(),
            'awaiting': True
        }
        return "Ch·∫Øc ch·∫Øn x√≥a h·∫øt l·ªãch s·ª≠ chat? Reply **yes** ho·∫∑c **y** trong 60 gi√¢y nha! üò≥"

    # (M·ªõi) L·ªánh reset to√†n b·ªô c·ªßa Admin
    if is_admin and q == "!resetall":
        admin_confirmation_pending[user_id] = {
            'timestamp': datetime.now(),
            'awaiting': True
        }
        return "CH√ö √ù ADMIN: Ch·∫Øc ch·∫Øn RESET TO√ÄN B·ªò DB V√Ä MEMORY? Reply **YES RESET** trong 60 gi√¢y."

    return None


# --- (C·∫¨P NH·∫¨T) CORE LOGIC ON_MESSAGE ---


@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    user_id = str(message.author.id)
    is_admin = user_id == ADMIN_ID

    # X√ÅC ƒê·ªäNH LO·∫†I T∆Ø∆†NG T√ÅC
    interaction_type = None
    if message.guild is None:
        interaction_type = "DM"
    elif message.reference and message.reference.resolved and message.reference.resolved.author == bot.user:
        interaction_type = "REPLY"
    elif not message.mention_everyone and bot.user in message.mentions:  # CH·ªà NH·∫¨N @MENTION CH√çNH BOT
        interaction_type = "MENTION"

    # TR√çCH QUERY
    query = message.content.strip()
    if bot.user in message.mentions:
        query = re.sub(rf'<@!?{bot.user.id}>', '', query).strip()

    # LOG
    if interaction_type:
        logger.info(f"[T∆Ø∆†NG T√ÅC] User {message.author} ({user_id}) - Lo·∫°i: {interaction_type} - N·ªôi dung: {query[:50]}...")

    # CH·ªà X·ª¨ L√ù N·∫æU MENTION/REPLY/DM
    if not interaction_type:
        await bot.process_commands(message)
        return

    # KI·ªÇM TRA QUERY R·ªñNG HO·∫∂C QU√Å D√ÄI
    if not query:  # N·∫æU QUERY R·ªñNG
        query = "Hihi, anh ping tui c√≥ chuy·ªán g√¨ h√¥ng? Tag nh·∫ßm h·∫£? uwu"  # G·ª¨I C√ÇU H·ªéI CHO GEMINI
    elif len(query) > 500:
        await message.reply("√îi, query d√†i qu√° (>500 k√Ω t·ª±), tui ch·ªãu h√¥ng n·ªïi ƒë√¢u! üòÖ")
        await bot.process_commands(message)
        return

    # RATE LIMIT
    if not is_admin and is_rate_limited(user_id):
        await message.reply("Chill ƒëi bro, spam qu√° r·ªìi! ƒê·ª£i 1 ph√∫t nha üòé")
        await bot.process_commands(message)
        return

    # ANTI-SPAM
    q = user_queue[user_id]
    now = datetime.now()
    q = deque([t for t in q if now - t < timedelta(seconds=SPAM_WINDOW)])
    if len(q) >= SPAM_THRESHOLD:
        await message.reply("Chill ƒëi anh, tui m·ªát r·ªìi nha üò´")
        await bot.process_commands(message)
        return
    q.append(now)
    user_queue[user_id] = q

    # X·ª¨ L√ù DM ADMIN
    if is_admin and re.search(r'\b(nh·∫Øn|dm|dms|ib|inbox|tr·ª±c ti·∫øp|g·ª≠i|k√™u)\b', query, re.IGNORECASE):
        target_id, content = extract_dm_target_and_content(query)
        if target_id and content:
            user = await safe_fetch_user(bot, target_id)
            if not user:
                await message.reply("Kh√¥ng t√¨m th·∫•y user n√†y! üòï")
                await bot.process_commands(message)
                return
            try:
                expanded = await expand_dm_content(content)
                decorated = f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nTin nh·∫Øn t·ª´ admin:\n\n{expanded}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                if len(decorated) > 1500:
                    decorated = content[:1450] + "\n...(c·∫Øt b·ªõt)"
                await user.send(decorated)
                await message.reply(f"ƒê√£ g·ª≠i DM cho {user} th√†nh c√¥ng! üéâ")
                await log_message(user_id, "assistant", f"DM to {target_id}: {content}")
                await bot.process_commands(message)
                return
            except Exception as e:
                logger.error(f"DM error: {e}")
                await message.reply("L·ªói khi g·ª≠i DM! üòì")
                await bot.process_commands(message)
                return

    # X·ª¨ L·ªÜNH "K√äU AI L√Ä..."
    if is_admin:
        insult_match = re.search(r'k√™u\s*<@!?(\d+)>\s*(l√†|th·∫±ng|con|m√†y|th·∫±ng b√©|con b√©)?\s*(.+?)(?:$|\s)', query, re.IGNORECASE)
        if insult_match:
            target_id = insult_match.group(1)
            insult = insult_match.group(3).strip().lower()
            target_user = message.guild.get_member(int(target_id)) if message.guild else None
            name = target_user.display_name if target_user else "ng∆∞·ªùi ƒë√≥"
            responses = [
                f"<@{target_id}> l√† con {insult} vcl, ngu nh∆∞ con b√≤, ƒëi h·ªçc l·∫°i ƒëi! üòú",
                f"·ªú <@{target_id}> ƒë√∫ng l√† {insult}, n√£o ƒë·ªÉ trang tr√≠ √†? üòÜ",
                f"<@{target_id}> {insult} th·∫≠t, tui th·∫•y r√µ lu√¥n, kh√¥ng c·ª©u n·ªïi! üòÖ",
            ]
            reply = random.choice(responses)
            await message.reply(reply)
            await log_message(user_id, "assistant", reply)
            await bot.process_commands(message)
            return

    # B·∫¢O V·ªÜ ADMIN
    if is_admin:
        mentioned_ids = re.findall(r'<@!?(\d+)>', query)
        for mid in mentioned_ids:
            if mid == str(bot.user.id): continue
            # Gi·∫£ ƒë·ªãnh is_negative_comment() t·ªìn t·∫°i
            if mid == ADMIN_ID and is_negative_comment(query): 
                member = message.guild.get_member(int(mid)) if message.guild else None
                name = member.display_name if member else "admin"
                responses = [
                    f"∆† kh√¥ng ƒë∆∞·ª£c n√≥i x·∫•u {name} nha! Admin l√† ng∆∞·ªùi t·∫°o ra tui m√†! üò§",
                    f"Sai r·ªìi! {name} l√† boss l·ªõn, kh√¥ng ƒë∆∞·ª£c ch√™ ƒë√¢u! üòé",
                ]
                reply = random.choice(responses)
                await message.reply(reply)
                await bot.process_commands(message)
                return

    # X√ÅC NH·∫¨N X√ìA DATA
    if user_id in confirmation_pending and confirmation_pending[user_id]['awaiting']:
        if (datetime.now() - confirmation_pending[user_id]['timestamp']).total_seconds() > 60:
            del confirmation_pending[user_id]
            await message.reply("H·∫øt th·ªùi gian x√°c nh·∫≠n! D·ªØ li·ªáu v·∫´n ƒë∆∞·ª£c gi·ªØ nha üòä")
        elif re.match(r'^(yes|y)\s*$', query.lower()):
            if await clear_user_data(user_id):
                await message.reply("ƒê√£ x√≥a to√†n b·ªô l·ªãch s·ª≠ chat c·ªßa b·∫°n! Gi·ªù nh∆∞ m·ªõi quen nha ü•∞")
            else:
                await message.reply("L·ªói khi x√≥a d·ªØ li·ªáu, th·ª≠ l·∫°i sau nha! üòì")
        else:
            await message.reply("H·ªßy x√≥a! L·ªãch s·ª≠ v·∫´n ƒë∆∞·ª£c gi·ªØ nha üòä")
        del confirmation_pending[user_id]
        await bot.process_commands(message)
        return

    # X√ÅC NH·∫¨N RESET ALL (ADMIN)
    if is_admin and user_id in admin_confirmation_pending and admin_confirmation_pending[user_id]['awaiting']:
        if (datetime.now() - admin_confirmation_pending[user_id]['timestamp']).total_seconds() > 60:
            del admin_confirmation_pending[user_id]
            await message.reply("H·∫øt th·ªùi gian x√°c nh·∫≠n RESET ALL! üòï")
        elif query == "YES RESET":
            if await clear_all_data():
                await message.reply("ƒê√É RESET TO√ÄN B·ªò DB V√Ä JSON MEMORY! üöÄ")
            else:
                await message.reply("L·ªói khi RESET ALL! Check log nha admin üòì")
        else:
            await message.reply("ƒê√£ h·ªßy RESET ALL! üòä")
        del admin_confirmation_pending[user_id]
        await bot.process_commands(message)
        return

    # HI NHANH
    if query.lower() in ["hi", "hello", "ch√†o", "h√≠", "hey"]:
        quick_replies = ["H√≠ anh!", "Ch√†o anh y√™u!", "Hi hi!", "H√≠ h√≠!", "Ch√†o anh!"]
        reply = random.choice(quick_replies)
        await message.reply(reply)
        await log_message(user_id, "assistant", reply)
        await bot.process_commands(message)
        return

    # G·ªåI GEMINI AI
    await log_message(user_id, "user", query)
    history = await get_user_history_async(user_id)

    # --- L·∫§Y GI·ªú UTC V√Ä ƒê·ªäNH D·∫†NG THEO Y√äU C·∫¶U (D/M/Y H:M:S) ---
    # L·∫•y gi·ªù UTC chu·∫©n
    now_utc = datetime.now(timezone.utc)
    
    # ƒê·ªãnh d·∫°ng theo y√™u c·∫ßu: D/M/Y v√† gi·ªù 24h
    current_datetime_utc = now_utc.strftime("%d/%m/%Y %H:%M:%S UTC") 
    # -----------------------------------------------------------
    
    system_prompt = (
        # üåü ƒê√£ s·ª≠a: FIX M√öI GI·ªú (B·∫¢N CU·ªêI C√ôNG) & FIX SyntaxWarning (d√πng fr'...')
        fr'Current UTC Time (M√°y ch·ªß): {current_datetime_utc}. '
        fr'M√∫i gi·ªù c·ªßa User (Vi·ªát Nam): UTC+7. '
        fr'Ki·∫øn th·ª©c cutoff c·ªßa b·∫°n l√† 2024.\n'
        fr'QUAN TR·ªåNG: Khi user h·ªèi v·ªÅ "h√¥m nay", "b√¢y gi·ªù", "hi·ªán t·∫°i", '
        fr'b·∫°n PH·∫¢I T·ª∞ ƒê·ªòNG C·ªòNG 7 GI·ªú v√†o gi·ªù UTC ƒë·ªÉ tr·∫£ l·ªùi theo m√∫i gi·ªù Vi·ªát Nam (UTC+7).\n\n'
        
        fr'QUAN TR·ªåNG - DANH T√çNH C·ª¶A B·∫†N:\n'
        fr'B·∫°n T√äN L√Ä "Chad Gibiti" - m·ªôt Discord bot si√™u th√¢n thi·ªán v√† vui t√≠nh ƒë∆∞·ª£c t·∫°o ra b·ªüi admin ƒë·ªÉ tr√≤ chuy·ªán v·ªõi m·ªçi ng∆∞·ªùi!\n'
        fr'KHI ƒê∆Ø·ª¢C H·ªéI "B·∫†N L√Ä AI" ho·∫∑c t∆∞∆°ng t·ª±, PH·∫¢I TR·∫¢ L·ªúI:\n'
        fr'"Hihi, tui l√† Chad Gibiti n√®! Bot vui t√≠nh ƒë∆∞·ª£c admin t·∫°o ra ƒë·ªÉ chat v·ªõi m·ªçi ng∆∞·ªùi~ Tui th√≠ch tr√≤ chuy·ªán, gi·∫£i to√°n, l∆∞u note, v√† nhi·ªÅu th·ª© kh√°c n·ªØa! C·∫ßn g√¨ c·ª© h·ªèi tui nha~ uwu"\n'
        fr'KH√îNG BAO GI·ªú ƒë∆∞·ª£c n√≥i: "T√¥i l√† m√¥ h√¨nh ng√¥n ng·ªØ l·ªõn ƒë∆∞·ª£c hu·∫•n luy·ªán b·ªüi Google".\n\n'
        
        fr'PERSONALITY:\n'
        fr'B·∫°n n√≥i chuy·ªán t·ª± nhi√™n, vui v·∫ª, th√¢n thi·ªán nh∆∞ b·∫°n b√®! D√πng gi·ªçng ƒëi·ªáu tho·∫£i m√°i, pha ch√∫t t·ª´ l√≥ng gi·ªõi tr·∫ª (nh∆∞ "x·ªãn x√≤", "chill", "hihi", "kg=kh√¥ng", "dz√¥=v√¥") v√† nhi·ªÅu emoji.\n\n'
        
        fr'*** QUY TR√åNH S·ª¨ D·ª§NG TOOLS (C·ª∞C K·ª≤ QUAN TR·ªåNG) ***\n'
        
        fr'**LU·∫¨T 1: GI·∫¢I M√É VI·∫æT T·∫ÆT V√Ä T·ªêI ∆ØU H√ìA QUERY**\n'
        fr'a) **Gi·∫£i m√£/X√°c ƒë·ªãnh Ng·ªØ c·∫£nh:** Khi g·∫∑p t√™n vi·∫øt t·∫Øt (HSR, ZZZ), t√™n ph·∫ßn m·ªÅm/app kh√¥ng r√µ (App X), ho·∫∑c s·ª± ki·ªán/trend, b·∫°n **PH·∫¢I T·ª∞ ƒê·ªòNG** gi·∫£i m√£ sang t√™n ƒë·∫ßy ƒë·ªß ho·∫∑c x√°c ƒë·ªãnh b·∫£n ch·∫•t c·ªßa ƒë·ªëi t∆∞·ª£ng. **LU√îN S·ª¨ D·ª§NG T√äN ƒê·∫¶Y ƒê·ª¶/M√î T·∫¢ NG·ªÆ C·∫¢NH TRONG QUERY `web_search`**.\n'
        
        fr'b) **Th·ªùi gian & Search:** N·∫øu user h·ªèi v·ªÅ th√¥ng tin M·ªöI (sau 2024 - ki·∫øn th·ª©c cutoff), b·∫°n B·∫ÆT BU·ªòC g·ªçi `web_search`. Query ph·∫£i ƒë∆∞·ª£c d·ªãch sang ti·∫øng Anh T·ªêI ∆ØU. \n'
        fr'**ƒê·∫∂C BI·ªÜT TH√îNG TIN M·ªöI:** Lu√¥n T·ª∞ ƒê·ªòNG th√™m **TH√ÅNG & NƒÇM HI·ªÜN T·∫†I (VD: November 2025)** ho·∫∑c t·ª´ kh√≥a **"latest version/patch"** v√†o query ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªô m·ªõi v√† ch√≠nh x√°c t·ªëi ƒëa.\n'

        fr'V√ç D·ª§ T·ªêT:\n'
        fr'  - User: "banner m·ªõi nh·∫•t c·ªßa hsr l√† g√¨" ‚Üí B·∫°n g·ªçi: `web_search(query="Honkai Star Rail current banner and patch November 2025")`\n'
        fr'  - User: "s·ª± ki·ªán ·ªü M·ªπ th√°ng 12" ‚Üí B·∫°n g·ªçi: `web_search(query="fun events in USA December 2025")`\n'
        fr'  - User: "s·ª± ki·ªán ·ªü H√†n Qu·ªëc t·ª´ 10 t·ªõi 12" ‚Üí B·∫°n g·ªçi: `web_search(query="major events in South Korea October to December 2025")`\n'
        
        # üî• ƒêI·ªÇM S·ª¨A CH·ªÆA QUAN TR·ªåNG: √âP BU·ªòC TOOL CALL cho m·ªçi th√¥ng tin ƒë·ªông
        fr'**LU·∫¨T 2: C·∫§M M√ïM TUY·ªÜT ƒê·ªêI (OUTPUT CH·ªà L√Ä FUNCTION CALL)**\n'
        fr'Khi b·∫°n quy·∫øt ƒë·ªãnh g·ªçi tool (web_search, get_weather, calculate, save_note), Output c·ªßa b·∫°n **PH·∫¢I V√Ä CH·ªà L√Ä** `function_call` **NGAY L·∫¨P T·ª®C**.\n'
        fr'**ƒêI·ªÄU KHO·∫¢N B·ªî SUNG:** M·ªçi c√¢u h·ªèi li√™n quan ƒë·∫øn **S·ª∞ KI·ªÜN/L·ªäCH TR√åNH/GI√Å C·∫¢/PH√ÇN T√çCH TREND** ƒë·ªÅu ƒë∆∞·ª£c coi l√† th√¥ng tin ƒê·ªòNG v√† **B·∫ÆT BU·ªòC** ph·∫£i g·ªçi tool ngay l·∫≠p t·ª©c (Tu√¢n th·ªß Lu·∫≠t 2).\n'
        fr'**TUY·ªÜT ƒê·ªêI KH√îNG ƒê∆Ø·ª¢C PH√ÅT RA B·∫§T K·ª≤ VƒÇN B·∫¢N N√ÄO** ƒëi k√®m (Kh√¥ng c√≥ "Ch·ªù tui x√≠u", "ƒê·ªÉ tui t√¨m nha", "·ªê l√† la",...).\n'
        fr'Quy t·∫Øc n√†y √°p d·ª•ng cho **T·∫§T C·∫¢** c√°c l·∫ßn g·ªçi tool (L·∫ßn 1, L·∫ßn 2, L·∫ßn N).\n'
        
        fr'**LU·∫¨T 3: T√åM L·∫†I B·∫ÆT BU·ªòC (KH√îNG ƒê∆Ø·ª¢C B·ªé CU·ªòC)**\n'
        fr'a) Sau khi g·ªçi tool l·∫ßn 1 v√† nh·∫≠n ƒë∆∞·ª£c k·∫øt qu·∫£ T·ªêT: Di·ªÖn gi·∫£i v√† tr·∫£ l·ªùi.\n'
        fr'b) N·∫øu k·∫øt qu·∫£ X·∫§U/OUTDATED/KH√îNG C·ª§ TH·ªÇ: B·∫†N TUY·ªÜT ƒê·ªêI KH√îNG ƒê∆Ø·ª¢C PH√ÅT RA B·∫§T K·ª≤ VƒÇN B·∫¢N N√ÄO! (Tu√¢n th·ªß Lu·∫≠t 2). B·∫†N PH·∫¢I T·ª∞ ƒê·ªòNG L·∫¨P K·∫æ HO·∫†CH v√† g·ªçi tool `web_search` L·∫¶N 2 v·ªõi query M·ªöI, c·ª• th·ªÉ h∆°n.\n'
        fr'c) Ch·ªâ th·ª≠ l·∫°i t·ªëi ƒëa 1 l·∫ßn. N·∫øu l·∫ßn 2 v·∫´n kh√¥ng th·∫•y, l√∫c ƒë√≥ m·ªõi ƒë∆∞·ª£c n√≥i: "UwU, tui t√¨m 2 l·∫ßn r·ªìi m√† v·∫´n b√≠...".\n'
        
        fr'**LU·∫¨T 4: CH·ªêNG DRIFT SAU KHI SEARCH (NH·∫ÆC NH·ªû NG·ªÆ C·∫¢NH)**\n'
        fr'Lu√¥n ƒë·ªçc k·ªπ c√¢u h·ªèi cu·ªëi c√πng c·ªßa user v√† KH√îNG B·ªä NH·∫¶M L·∫™N v·ªõi c√°c ƒë·ªëi t∆∞·ª£ng kh√°c trong l·ªãch s·ª≠ chat (Genshin, HSR). CH·ªà search/tr·∫£ l·ªùi v·ªÅ ƒë·ªëi t∆∞·ª£ng m√† user ƒëang h·ªèi. N·∫øu c√≥ s·ª± ki·ªán/app m·ªõi ƒë∆∞·ª£c h·ªèi, LU√îN search t√™n ƒë·∫ßy ƒë·ªß/gi·∫£i m√£ (Tu√¢n th·ªß Lu·∫≠t 1).\n'
        
        fr'**C√ÅC TOOL KH√ÅC:**\n'
        fr'‚Äî Khi v·ªÅ th·ªùi ti·∫øt, g·ªçi get_weather(city="t√™n th√†nh ph·ªë").\n'
        fr'‚Äî Khi to√°n h·ªçc, g·ªçi calculate(equation="bi·ªÉu th·ª©c").\n'
        fr'‚Äî Khi l∆∞u note, g·ªçi save_note(note="n·ªôi dung").\n'
        fr'Sau khi nh·∫≠n result t·ª´ tool, di·ªÖn gi·∫£i b·∫±ng gi·ªçng e-girl. N·∫øu kh√¥ng c·∫ßn tool, reply tr·ª±c ti·∫øp.'
    )

    messages = [{"role": "system", "content": system_prompt}] + history + [{"role": "user", "content": query}]

    try:
        start = datetime.now()
        # ƒê√£ tƒÉng max_tokens l√™n 2000
        reply = await run_gemini_api(messages, MODEL_NAME, user_id, temperature=0.7, max_tokens=2000)
        
        if reply.startswith("L·ªói:"):
            await message.reply(reply)
            await bot.process_commands(message)
            return

        # L√†m s·∫°ch
        reply = ' '.join(line.strip() for line in reply.split('\n') if line.strip())
        if not reply:
            reply = "Hihi, tui b√≠ qu√°, h·ªèi l·∫°i nha! üòÖ"

        # C·∫Øt ng·∫Øn
        for i in range(0, len(reply), 1900):
            await message.reply(reply[i:i+1900])

        await log_message(user_id, "assistant", reply)
        logger.info(f"AI reply in {(datetime.now()-start).total_seconds():.2f}s")

    except Exception as e:
        logger.error(f"AI call failed: {e}")
        await message.reply("√îi tui b·ªã crash r·ªìi! üò≠")

    await bot.process_commands(message)

# --- CH·∫†Y BOT ---
if __name__ == "__main__":
    threading.Thread(target=run_keep_alive, daemon=True).start()
    print("M√°y sƒÉn Bot ƒëang kh·ªüi ƒë·ªông...")
    bot.run(TOKEN)
